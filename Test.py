from StockPrediction import StockPrediction
import pandas as pd
import warnings
warnings.filterwarnings("ignore")

#sklearn Imports

#Basic
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix

#Models
from sklearn.naive_bayes import GaussianNB
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import BaggingClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.mixture import GaussianMixture

# Import packages
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from keras.optimizers import Adam, SGD, RMSprop, Adadelta, Adagrad, Adamax, Nadam, Ftrl
from keras.callbacks import EarlyStopping
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.metrics import accuracy_score
from bayes_opt import BayesianOptimization
from keras.layers import LeakyReLU
LeakyReLU = LeakyReLU(alpha=0.1)

class Test():
    """
    This is a super class that contains ML and NN Classes.
    """

    def __init__(self):
        """
        Initializes the Test Class.
        """
        pass

    class ML():
        """
        This is a class for training and evaluating machine learning models for financial forecasting.

        Attributes:
        mode (str): The mode of the class, either 'binary' or 'multi'. Determines how the labels for the data are generated.
        sampling (str): The sampling method for the data, either 'undersampled' or 'oversampled'.

        Methods:
        read_data(csv_path = 'Dataset.csv'): Reads in a CSV file containing financial data and generates training and testing datasets, as well as a list of unique companies in the dataset.
        gen_labels(changes): Generates labels for the data based on the 'mode' attribute and a list of changes in stock prices.
        evaluate_data(): Trains and evaluates a variety of machine learning models using the training and testing datasets generated by 'read_data'.
        """
        def init(self, mode, sampling):
            """
            Initializes the ML class with the specified mode and sampling method.
            Parameters:
            mode (str): The mode of the class, either 'binary' or 'multi'.
            sampling (str): The sampling method for the data, either 'undersampled' or 'oversampled'.
            """
            self.mode = mode
            self.sampling = sampling

        def read_data(self, csv_path = 'Dataset.csv'):
            """
            Reads in a CSV file containing financial data and generates training and testing datasets, as well as a list of unique companies in the dataset.

            Parameters:
            csv_path (str, optional): The file path for the CSV file. Default is 'Dataset.csv'.

            Returns:
            None
            """
            df = pd.read_csv(csv_path)
            X = df[[column for column in df.columns if column not in ['Company', 'Period', 'Date Range', 'Change', 'Label', 'Unnamed: 0']]]
            labels = []
            changes = list(df['Change'])
            y = pd.DataFrame()
            y['Label'] = self.gen_labels(changes)
            Xtr, Xts, ytr, yts = train_test_split(X, y, test_size = 0.3)
            companies = [company for company in list(set(list(df['Company'])))]
            series_description = \
            f"""
            TEST SERIES\n
            Dataset Companies ({len(companies)}) 
            {companies}
            """

            self.stock_prediction_obj = StockPrediction(Xtr = Xtr, ytr = ytr,
                                                        Xts = Xts, yts = yts,
                                                        sampling = self.sampling,
                                                        description = series_description)

        def gen_labels(self, changes):
            """
            Generates labels for the data based on the 'mode' attribute and a list of changes in stock prices.

            Parameters:
            changes (list): A list of changes in stock prices.

            Returns:
            labels (list): A list of labels for the data.
            """
            labels = []
            if self.mode == 'binary':
                for change in changes:
                    if change < 1:
                        labels.append(0)
                    elif change >= 1:
                        labels.append(1)
            elif self.mode == 'multi':
                for change in changes:
                    if change <= -1:
                        labels.append(0)
                    elif change > -1 and change < 1:
                        labels.append(1)
                    elif change >= 1:
                        labels.append(2)
            return labels

        def evaluate_data(self):
            """
            Trains and evaluates a variety of machine learning models using the training and testing datasets generated by 'read_data'.

            Parameters:
            None

            Returns:
            models (list): List of trained models.
            cms (list): List of Confusion Matrices
            """
            if self.mode == 'binary':
                model_1, cm_1 = self.stock_prediction_obj.evaluate_model(model = GaussianNB())
                model_2, cm_2 = self.stock_prediction_obj.evaluate_model(model = LogisticRegression(class_weight = 'balanced'))
                model_3, cm_3 = self.stock_prediction_obj.evaluate_model(model = KNeighborsClassifier())
                model_4, cm_4 = self.stock_prediction_obj.evaluate_model(model = SVC(class_weight = 'balanced'))
                model_5, cm_5 = self.stock_prediction_obj.evaluate_model(model = DecisionTreeClassifier(class_weight = 'balanced'))
                model_6, cm_6 = self.stock_prediction_obj.evaluate_model(model = BaggingClassifier())
                model_7, cm_7 = self.stock_prediction_obj.evaluate_model(model = GradientBoostingClassifier())
                model_8, cm_8 = self.stock_prediction_obj.evaluate_model(model = RandomForestClassifier(class_weight = 'balanced'))
                models = [model_1, model_2, model_3, model_4, model_5, model_6, model_7, model_8]
                cms = [cm_1, cm_2, cm_3, cm_4, cm_5, cm_6, cm_7, cm_8]
            elif self.mode == 'multi':
                model_1, cm_1 = self.stock_prediction_obj.evaluate_model(model = LogisticRegression(multi_class = 'multinomial', class_weight = 'balanced'))
                model_2, cm_2 = self.stock_prediction_obj.evaluate_model(model = DecisionTreeClassifier(class_weight = 'balanced'))
                model_3, cm_3 = self.stock_prediction_obj.evaluate_model(model = RandomForestClassifier(class_weight = 'balanced'))
                model_4, cm_4 = self.stock_prediction_obj.evaluate_model(model = GaussianMixture())
                model_5, cm_5 = self.stock_prediction_obj.evaluate_model(model = KNeighborsClassifier())
                model_6, cm_6 = self.stock_prediction_obj.evaluate_model(model = SVC(class_weight = 'balanced'))
                model_7, cm_7 = self.stock_prediction_obj.evaluate_model(model = BaggingClassifier())
                model_8, cm_8 = self.stock_prediction_obj.evaluate_model(model = GradientBoostingClassifier())
                models = [model_1, model_2, model_3, model_4, model_5, model_6, model_7, model_8]
                cms = [cm_1, cm_2, cm_3, cm_4, cm_5, cm_6, cm_7, cm_8]
            return(models, cms)

    class NN():
        """
        Class to build, evaluate and use a neural network model for stock price prediction.
        
        Parameters:
        mode (str): either 'binary' or 'multi', indicating the type of labels to use.
                    If 'binary', the model will predict whether the stock price will increase or decrease.
                    If 'multi', the model will predict whether the stock price will increase, decrease or stay the same.
        
        Attributes:
        stock_prediction_obj (StockPrediction): object with the training and test data for the model.
        """
        
        def __init__(self, mode):
            self.mode = mode
        
        def read_data(self, mode, csv_path = 'Dataset.csv'):
            """
            Reads and preprocesses the data from the given csv file.
            
            Parameters:
            mode (str): either 'binary' or 'multi', indicating the type of labels to use.
                    If 'binary', the model will predict whether the stock price will increase or decrease.
                    If 'multi', the model will predict whether the stock price will increase, decrease or stay the same.
            csv_path (str): path to the csv file with the data.
            
            Returns:
            None
            """
            df = pd.read_csv(csv_path)
            # Select all columns except 'Company', 'Period', 'Date Range', 'Change', 'Label', 'Unnamed: 0'
            X = df[[column for column in df.columns if column not in ['Company', 'Period', 'Date Range', 'Change', 'Label', 'Unnamed: 0']]]
            labels = []
            changes = list(df['Change'])
            # Generate labels based on the 'Change' column
            X['Label'] = self.gen_labels(changes)
            
            # Split the data into train, validate, and test sets
            train, validate, test = np.split(X.sample(frac=1, random_state=42),[int(.6*len(df)), int(.8*len(df))])
            # Select all columns except 'Company','Period','Date Range','Change', 'Label','Unnamed: 0'
            Xtr = train[[column for column in df.columns if column not in {'Company','Period','Date Range','Change', 'Label','Unnamed: 0'}]]
            ytr=train[['Label']]
            Xts = test[[column for column in df.columns if column not in {'Company','Period','Date Range','Change', 'Label','Unnamed: 0'}]]
            yts=test[['Label']]
            Xval =  validate[[column for column in df.columns if column not in {'Company','Period','Date Range','Change', 'Label','Unnamed: 0'}]]
            yval=validate[['Label']]
            
            companies = [company for company in list(set(list(df['Company'])))]
            series_description = \
            f"""
            TEST SERIES\n
            Dataset Companies ({len(companies)}) 
            {companies}
            """
            self.stock_prediction_obj = StockPrediction(Xtr = Xtr, ytr = ytr,
                                                        Xts = Xts, yts = yts,Xval=Xval,yval=yval,
                                                        sampling = None,
                                                        description = series_description)

        def gen_labels(self, changes):
            """
            Generates labels for the data based on the 'Change' column.
            
            Parameters:
            changes (list): list of values in the 'Change' column.
            
            Returns:
            list: list of labels generated based on the 'Change' column.
            """
            labels = []
            if self.mode == 'binary':
                for change in changes:
                    if change < 1:
                        labels.append(0)
                    elif change >= 1:
                        labels.append(1)
            elif self.mode == 'multi':
                for change in changes:
                    if change <= -1:
                        labels.append(0)
                    elif change > -1 and change < 1:
                        labels.append(1)
                    elif change >= 1:
                        labels.append(2)
            return(labels)
        
        def evaluate_data(self):
            """
            Evaluates the model by performing hyperparameter tuning using Bayesian optimization.
            
            Parameters:
            None
            
            Returns:
            nn : Trained Neural Network Model.
            cm : Confusion Matrix.
            """
            params_nn1 ={
                'neurons': (10, 100),
                'activation':(0, 9),
                'optimizer':(0,7),
                'learning_rate':(0.01, 1),
                'batch_size':(200, 1000),
                'epochs':(20, 100),
                'layers1':(1,3),
                'layers2':(1,3),
                'normalization':(0,1),
                'dropout':(0,1),
                'dropout_rate':(0,0.3)
            }
            # Run Bayesian Optimization
            nn_bo = BayesianOptimization(self.stock_prediction_obj.nn_cl_bo2, params_nn1, random_state=111)
            nn_bo.maximize(init_points=25, n_iter=4)

            #print the results of the hyperparameter tuning 
            params_nn_ = nn_bo.max['params']
            learning_rate = params_nn_['learning_rate']
            activationL = ['relu', 'sigmoid', 'softplus', 'softsign', 'tanh', 'selu',
                        'elu', 'exponential', 'LeakyReLU','relu']
            params_nn_['activation'] = activationL[round(params_nn_['activation'])]
            params_nn_['batch_size'] = round(params_nn_['batch_size'])
            params_nn_['epochs'] = round(params_nn_['epochs'])
            params_nn_['layers1'] = round(params_nn_['layers1'])
            params_nn_['layers2'] = round(params_nn_['layers2'])
            params_nn_['neurons'] = round(params_nn_['neurons'])
            optimizerL = ['Adam', 'SGD', 'RMSprop', 'Adadelta', 'Adagrad', 'Adamax', 'Nadam', 'Ftrl','Adam']
            optimizerD= {'Adam':Adam(lr=learning_rate), 'SGD':SGD(lr=learning_rate),
                        'RMSprop':RMSprop(lr=learning_rate), 'Adadelta':Adadelta(lr=learning_rate),
                        'Adagrad':Adagrad(lr=learning_rate), 'Adamax':Adamax(lr=learning_rate),
                        'Nadam':Nadam(lr=learning_rate), 'Ftrl':Ftrl(lr=learning_rate)}
            params_nn_['optimizer'] = optimizerD[optimizerL[round(params_nn_['optimizer'])]]

            # Fitting Neural Network
            es = EarlyStopping(monitor='accuracy', mode='max', verbose=0, patience=20)

            build_model_override = lambda: self.stock_prediction_obj.nn_cl_fun(params_nn_=params_nn_)
            nn = KerasClassifier(build_fn= build_model_override, epochs=params_nn_['epochs'], batch_size=params_nn_['batch_size'],
                                    verbose=0)
            nn.fit(self.Xtr, self.ytr, validation_data=(self.Xval, self.yval), verbose=1)
            yhat_classes = (nn.predict(self.Xts) > 0.5).astype("int32")
                
            yhat_classes = yhat_classes[:, 0]
                    
            # accuracy: (tp + tn) / (p + n)
            accuracy = accuracy_score(self.yts, yhat_classes)
            print('Accuracy: %f' % accuracy) 
                
            accuracy_perc = round(accuracy*100, 5)
            print(f"Accuracy                : {accuracy_perc}%")
            cm=confusion_matrix(self.yts,yhat_classes)
            return(nn, cm)